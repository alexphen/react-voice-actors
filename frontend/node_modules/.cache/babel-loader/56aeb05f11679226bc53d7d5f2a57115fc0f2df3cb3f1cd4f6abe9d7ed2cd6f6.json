{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst types = require('../types.js');\n\n// define implementation class\nclass ResultSetImpl {\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object', errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType, errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function', errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n        // otherwise, use the default fetch type map (calculated from the\n        // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION, metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      let converter;\n      const userConverter = metadata.converter;\n      if (metadata.dbType === types.DB_TYPE_NUMBER && metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = v => v === null ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE || metadata.dbType === types.DB_TYPE_BINARY_FLOAT || metadata.dbType === types.DB_TYPE_DATE || metadata.dbType === types.DB_TYPE_TIMESTAMP || metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ || metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = v => v === null ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = v => v === null ? null : v.toString('hex').toUpperCase();\n        }\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = v => userConverter(internalConverter(v));\n      }\n      if (converter) {\n        metadata.converter = converter;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB || info.fetchType === types.DB_TYPE_NCLOB || info.fetchType === types.DB_TYPE_BLOB) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n}\nmodule.exports = ResultSetImpl;","map":{"version":3,"names":["constants","require","errors","nodbUtil","settings","types","ResultSetImpl","_determineFetchType","metadata","options","fetchType","converter","fetchTypeHandler","result","undefined","assert","ERR_FETCH_TYPE_HANDLER_RETURN_VALUE","type","DbType","ERR_FETCH_TYPE_HANDLER_TYPE","ERR_FETCH_TYPE_HANDLER_CONVERTER","fetchTypeMap","has","name","get","DEFAULT","DB_TYPE_FETCH_TYPE_MAP","dbType","map","DB_TYPE_CONVERSION_MAP","actualFetchType","throwErr","ERR_UNSUPPORTED_CONVERSION","thin","userConverter","DB_TYPE_NUMBER","v","parseFloat","DB_TYPE_VARCHAR","DB_TYPE_BINARY_DOUBLE","DB_TYPE_BINARY_FLOAT","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","toString","DB_TYPE_RAW","toUpperCase","internalConverter","_getConnImpl","_parentObj","_setup","metaData","connection","_impl","lobIndices","dbObjectIndices","nestedCursorIndices","converterIndices","outFormat","fetchArraySize","dbObjectAsPojo","maxRows","names","Map","i","length","set","info","dbTypeClass","cls","_getDbObjectClass","addTypeProperties","DB_TYPE_CURSOR","push","DB_TYPE_CLOB","DB_TYPE_NCLOB","DB_TYPE_BLOB","DB_TYPE_OBJECT","seqNum","close","throwNotImplemented","getRows","module","exports"],"sources":["C:/Users/aphen/OneDrive/Documents/GitHub/react-voice-actors/node_modules/oracledb/lib/impl/resultset.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst types = require('../types.js');\n\n// define implementation class\nclass ResultSetImpl {\n\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object',\n          errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType,\n            errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function',\n            errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType =\n            types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n      // otherwise, use the default fetch type map (calculated from the\n      // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION,\n          metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      let converter;\n      const userConverter = metadata.converter;\n      if (metadata.dbType === types.DB_TYPE_NUMBER &&\n          metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = (v) => (v === null) ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE ||\n           metadata.dbType === types.DB_TYPE_BINARY_FLOAT ||\n           metadata.dbType === types.DB_TYPE_DATE ||\n           metadata.dbType === types.DB_TYPE_TIMESTAMP ||\n           metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ ||\n           metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = (v) => (v === null) ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = (v) => (v === null) ? null : v.toString('hex').toUpperCase();\n        }\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = (v) => userConverter(internalConverter(v));\n      }\n      if (converter) {\n        metadata.converter = converter;\n      }\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB ||\n          info.fetchType === types.DB_TYPE_NCLOB ||\n          info.fetchType === types.DB_TYPE_BLOB) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n\n}\n\nmodule.exports = ResultSetImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}