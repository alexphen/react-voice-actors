{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst utils = require(\"../utils\");\nconst constants = require(\"../constants.js\");\nconst Message = require(\"./base.js\");\nconst ThinDbObjectImpl = require(\"../../dbObject.js\");\nconst ThinLobImpl = require(\"../../lob.js\");\nconst errors = require('../../../errors');\nconst types = require('../../../types.js');\n\n/**\n * Handles data like row header, rowdata , ... recevied from an RPC Execute\n *\n * @class MessageWithData\n * @extends {Message}\n */\nclass MessageWithData extends Message {\n  constructor(connection, statement = null, options = null) {\n    super(connection);\n    this.statement = statement;\n    this.options = options;\n    this.offset = 0;\n    this.numExecs = 1;\n    this.arrayDmlRowCounts = false;\n    this.requiresDefine = false;\n    this.rowIndex = statement.bufferRowCount || 0;\n    this.dmlRowCounts = [];\n    this.batchErrors = false;\n    this.outVariables = [];\n    this.inFetch = false;\n    this.parseOnly = false;\n    this.resultSetsToSetup = [];\n    this.deferredErr = null;\n  }\n\n  /**\n    * processMessage() - Process the data type message\n    */\n  processMessage(buf, messageType) {\n    if (messageType === constants.TNS_MSG_TYPE_DESCRIBE_INFO) {\n      buf.skipBytesChunked();\n      const prevQueryVars = this.statement.queryVars;\n      this.statement.queryVars = [];\n      this.statement.numQueryVars = 0;\n      this.statement.bufferRowCount = 0;\n      this.statement.bufferRowIndex = 0;\n      this.processDescribeInfo(buf, this.resultSet, prevQueryVars);\n      this.outVariables = this.statement.queryVars;\n    } else if (messageType === constants.TNS_MSG_TYPE_ROW_HEADER) {\n      this.processRowHeader(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_ROW_DATA) {\n      this.processRowData(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_IMPLICIT_RESULTSET) {\n      this.processImplicitResultSet(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_BIT_VECTOR) {\n      this.processBitVector(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_IO_VECTOR) {\n      this.processIOVector(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS) {\n      this.flushOutBinds = true;\n    } else if (messageType === constants.TNS_MSG_TYPE_ERROR) {\n      this.processErrorInfo(buf);\n    } else {\n      super.processMessage(buf, messageType);\n    }\n  }\n  hasMoreData() {\n    return !this.processedError && !this.flushOutBinds;\n  }\n  processErrorInfo(buf) {\n    super.processErrorInfo(buf);\n    if (this.errorInfo.cursorId !== 0) {\n      this.statement.cursorId = this.errorInfo.cursorId;\n    }\n    if (!this.statement.isPlSql) {\n      this.statement.rowCount = this.errorInfo.rowCount;\n    }\n    // we do not set the lastRowid if the rows affected is 0\n    if (this.errorInfo.rowCount > 0) {\n      this.statement.lastRowid = utils.encodeRowID(this.errorInfo.rowID);\n    }\n    this.options.batchErrors = this.errorInfo.batchErrors;\n    if (this.batchErrors && this.options.batchErrors === null) {\n      this.options.batchErrors = [];\n    }\n    if (this.errorInfo.num === constants.TNS_ERR_NO_DATA_FOUND && this.statement.isQuery) {\n      this.errorInfo.num = 0;\n      this.errorOccurred = false;\n      this.statement.moreRowsToFetch = false;\n    } else if (this.errorInfo.num !== 0 && this.errorInfo.cursorId !== 0) {\n      this.connection.statementCache.delete(this.statement.sql);\n      this.statement.returnToCache = false;\n    }\n    if (this.errorInfo.batchErrors) {\n      this.errorOccurred = false;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // If we have fetched this column earlier, we set that\n  // fetch type for the describe info variable received\n  // assuming the returned column order is same as previous.\n  //---------------------------------------------------------------------------\n  _adjustFetchType(pVar, cVar) {\n    if (cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_CLOB && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG || cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_BLOB && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {\n      cVar.type = pVar.fetchInfo.fetchType;\n      cVar.maxSize = pVar.maxSize;\n    }\n  }\n  processDescribeInfo(buf, resultSet, prevQueryVars) {\n    const statement = resultSet.statement;\n    buf.skipUB4(); // max row size\n    statement.numQueryVars = buf.readUB4();\n    if (statement.numQueryVars > 0) {\n      buf.skipUB1();\n    }\n    resultSet.metadata = [];\n    for (let i = 0; i < statement.numQueryVars; i++) {\n      const variable = this.processColumnInfo(buf, i + 1);\n      if (prevQueryVars && i < prevQueryVars.length) {\n        this._adjustFetchType(prevQueryVars[i], variable);\n      }\n      statement.queryVars.push(variable);\n      resultSet.metadata.push(variable.fetchInfo);\n    }\n    let numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked(); // current date\n    }\n\n    buf.skipUB4(); // dcbflag\n    buf.skipUB4(); // dcbmdbz\n    buf.skipUB4(); // dcbmnpr\n    buf.skipUB4(); // dcbmxpr\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked();\n    }\n    this.resultSetsToSetup.push(resultSet);\n  }\n  processColumnInfo(buf, columnNum) {\n    const dataType = buf.readUInt8();\n    buf.skipUB1(); // flags\n    const precision = buf.readInt8();\n    let scale;\n    if (dataType === constants.TNS_DATA_TYPE_NUMBER || dataType === constants.TNS_DATA_TYPE_INTERVAL_DS || dataType === constants.TNS_DATA_TYPE_TIMESTAMP || dataType === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ || dataType === constants.TNS_DATA_TYPE_TIMESTAMP_TZ) {\n      scale = buf.readSB2();\n    } else {\n      scale = buf.readInt8();\n    }\n    const maxSize = buf.readUB4();\n    buf.skipUB4(); // max number of array elements\n    buf.skipUB4(); // cont flags\n    let oid;\n    let numBytes = buf.readUB4(); // OID\n    if (numBytes > 0) {\n      oid = Buffer.from(buf.readBytesWithLength());\n    }\n    buf.skipUB2(); // version\n    buf.skipUB2(); // character set id\n    const csfrm = buf.readUInt8(); // character set form\n    let size = buf.readUB4();\n    if (dataType === constants.TNS_DATA_TYPE_RAW) {\n      size = maxSize;\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.skipUB4(); // oaccolid\n    }\n\n    const nullable = Boolean(buf.readUInt8());\n    buf.skipUB1(); // v7 length of name\n    let name;\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      name = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    let schema;\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      schema = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    numBytes = buf.readUB4();\n    let typeName;\n    if (numBytes > 0) {\n      typeName = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    buf.skipUB2(); // column position\n    buf.skipUB4(); // uds flag\n\n    // build metadata\n    const fetchInfo = {\n      name: name,\n      dbType: types.getTypeByOraTypeNum(dataType, csfrm),\n      nullable: nullable\n    };\n    switch (fetchInfo.dbType) {\n      case types.DB_TYPE_VARCHAR:\n      case types.DB_TYPE_NVARCHAR:\n      case types.DB_TYPE_CHAR:\n      case types.DB_TYPE_NCHAR:\n      case types.DB_TYPE_RAW:\n        fetchInfo.byteSize = size;\n        break;\n      case types.DB_TYPE_NUMBER:\n        fetchInfo.precision = precision;\n        break;\n      case types.DB_TYPE_TIMESTAMP:\n      case types.DB_TYPE_TIMESTAMP_TZ:\n      case types.DB_TYPE_TIMESTAMP_LTZ:\n        fetchInfo.precision = scale;\n        break;\n      case types.DB_TYPE_OBJECT:\n        fetchInfo.dbTypeClass = this.connection._getDbObjectType(schema, typeName, undefined, oid);\n        if (fetchInfo.dbTypeClass.partial) {\n          this.connection._partialDbObjectTypes.push(fetchInfo.dbTypeClass);\n        }\n        break;\n      default:\n        break;\n    }\n    if (fetchInfo.dbType === types.DB_TYPE_NUMBER) {\n      fetchInfo.scale = scale;\n    }\n    return {\n      fetchInfo: fetchInfo,\n      type: fetchInfo.dbType,\n      maxSize: maxSize,\n      columnNum: columnNum,\n      values: new Array(this.options.fetchArraySize)\n    };\n  }\n  processRowHeader(buf) {\n    buf.skipUB1(); // flags\n    buf.skipUB2(); // num requests\n    buf.skipUB4(); // iteration number\n    buf.skipUB4(); // num iters\n    buf.skipUB2(); // buffer length\n    let numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      this.bitVector = Buffer.from(buf.readBytesWithLength());\n    }\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked(); // rxhrid\n    }\n  }\n\n  isDuplicateData(columnName) {\n    if (!this.bitVector) {\n      return false;\n    }\n    const byteNum = Math.floor(columnName / 8);\n    const bitNum = columnName % 8;\n    return (this.bitVector[byteNum] & 1 << bitNum) === 0;\n  }\n  processRowData(buf) {\n    let value;\n    for (const [col, variable] of this.outVariables.entries()) {\n      if (variable.isArray) {\n        variable.numElementsInArray = buf.readUB4();\n        const values = new Array(variable.numElementsInArray).fill(null);\n        for (let pos = 0; pos < variable.numElementsInArray; pos++) {\n          value = this.processColumnData(buf, variable, pos);\n          values[pos] = value;\n        }\n        variable.values[this.rowIndex] = values;\n      } else if (this.statement.isReturning) {\n        const numRows = buf.readUB4();\n        const values = Array(numRows).fill(null);\n        for (let j = 0; j < numRows; j++) {\n          values[j] = this.processColumnData(buf, variable, j);\n        }\n        variable.values[this.rowIndex] = values;\n      } else if (this.isDuplicateData(col)) {\n        if (this.rowIndex === 0 && variable.outConverter) {\n          value = variable.lastRawValue;\n        } else {\n          value = variable.values[this.statement.lastRowIndex];\n        }\n        variable.values[this.rowIndex] = value;\n      } else {\n        value = this.processColumnData(buf, variable, this.rowIndex);\n        variable.values[this.rowIndex] = value;\n      }\n    }\n    this.rowIndex++;\n    if (this.inFetch) {\n      this.statement.lastRowIndex = this.rowIndex - 1;\n      this.statement.bufferRowCount++;\n      this.bitVector = null;\n    }\n  }\n  processIOVector(buf) {\n    let numBytes;\n    buf.skipUB1(); // flag\n    const temp16 = buf.readUB2(); // num requests\n    const temp32 = buf.readUB4(); // iter num\n    const numBinds = temp32 * 256 + temp16;\n    buf.skipUB4(); // num iters this time\n    buf.skipUB2(); // uac buffer length\n    numBytes = buf.readUB2(); // bit vector for fast fetch\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    numBytes = buf.readUB2(); // rowid\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    this.outVariables = [];\n    for (let i = 0; i < numBinds; i++) {\n      // bind directions\n      const bindInfo = this.statement.bindInfoList[i];\n      bindInfo.bindDir = buf.readUInt8();\n      if (bindInfo.bindDir === constants.TNS_BIND_DIR_INPUT) {\n        continue;\n      }\n      this.outVariables.push(bindInfo.bindVar);\n    }\n  }\n  processColumnData(buf, variable) {\n    const dbType = variable.type;\n    const oraTypeNum = dbType._oraTypeNum;\n    const csfrm = dbType._csfrm;\n    const maxSize = variable.maxSize;\n    let colValue = null;\n    if (maxSize === 0 && oraTypeNum !== constants.TNS_DATA_TYPE_LONG && oraTypeNum !== constants.TNS_DATA_TYPE_LONG_RAW && oraTypeNum !== constants.TNS_DATA_TYPE_UROWID) {\n      colValue = null;\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR || oraTypeNum === constants.TNS_DATA_TYPE_CHAR || oraTypeNum === constants.TNS_DATA_TYPE_LONG) {\n      if (csfrm === constants.CSFRM_NCHAR) {\n        buf.caps.checkNCharsetId();\n      }\n      colValue = buf.readStr(csfrm);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_RAW || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {\n      colValue = buf.readBytesWithLength();\n      if (colValue !== null) {\n        colValue = Buffer.from(colValue);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER) {\n      colValue = buf.readOracleNumber();\n      if (!this.inFetch && colValue !== null) colValue = parseFloat(colValue);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ) {\n      const useLocalTime = oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP;\n      colValue = buf.readOracleDate(useLocalTime);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_ROWID) {\n      if (!this.inFetch) {\n        colValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      } else {\n        const numBytes = buf.readUInt8();\n        if (isNullLength(numBytes)) {\n          colValue = null;\n        } else {\n          const rowid = buf.readRowID();\n          colValue = utils.encodeRowID(rowid);\n        }\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_UROWID) {\n      if (!this.inFetch) {\n        colValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      } else {\n        colValue = buf.readURowID();\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {\n      colValue = buf.readBinaryDouble();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {\n      colValue = buf.readBinaryFloat();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {\n      colValue = buf.readOracleNumber();\n      if (colValue !== null) colValue = parseFloat(colValue);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {\n      const numBytes = buf.readUInt8();\n      if (isNullLength(numBytes)) {\n        colValue = null;\n      } else {\n        colValue = this.createCursorFromDescribe(buf);\n        colValue.statement.cursorId = buf.readUB2();\n        // If the cursor ID is 0 for the returned ref cursor then\n        // it is an invalid cursor\n        if (colValue.statement.cursorId === 0 && variable.dir !== constants.BIND_IN) {\n          if (this.options.nullifyInvalidCursor) {\n            colValue = null;\n          } else {\n            errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n          }\n        }\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n      colValue = buf.readBool();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB) {\n      const bvalue = buf.readUB4();\n      if (bvalue > 0) {\n        // Non Null data in column\n        colValue = new ThinLobImpl();\n        const length = buf.readUB8();\n        const chunkSize = buf.readUB4();\n        const locator = Buffer.from(buf.readBytesWithLength());\n        colValue.init(this.connection, locator, dbType, length, chunkSize);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {\n      colValue = buf.readOson();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n      const obj = buf.readDbObject();\n      if (obj.packedData) {\n        const objType = variable.fetchInfo ? variable.fetchInfo.dbTypeClass : variable.typeClass;\n        colValue = new ThinDbObjectImpl(objType, obj.packedData);\n        colValue.toid = obj.toid;\n        colValue.oid = obj.oid;\n      }\n    } else {\n      errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE, dbType.num, variable.columnNum);\n    }\n    if (!this.inFetch) {\n      const actualNumBytes = buf.readSB4();\n      if (actualNumBytes < 0 && oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n        colValue = null;\n      } else if (actualNumBytes !== 0 && colValue !== null) {\n        this.saveDeferredErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_LONG || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW || variable.maxSize > buf.caps.maxStringSize) {\n      buf.skipSB4(); // null indicator\n      buf.skipUB4(); // return code\n    }\n\n    return colValue;\n  }\n  processReturnParameter(buf) {\n    let keywordNum = 0;\n    let keyTextValue;\n    let numParams = buf.readUB2(); // al8o4l (ignored)\n\n    for (let i = 0; i < numParams; i++) {\n      buf.skipUB4();\n    }\n    let numBytes = buf.readUB2(); // al8txl (ignored)\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    numParams = buf.readUB2(); // num key/value pairs\n    for (let i = 0; i < numParams; i++) {\n      numBytes = buf.readUB2(); // key\n      if (numBytes > 0) {\n        keyTextValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      }\n      numBytes = buf.readUB2(); // value\n      if (numBytes > 0) {\n        buf.skipBytesChunked();\n      }\n      keywordNum = buf.readUB2(); // keyword num\n      if (keywordNum === constants.TNS_KEYWORD_NUM_CURRENT_SCHEMA) {\n        this.connection.currentSchema = keyTextValue;\n      } else if (keywordNum === constants.TNS_KEYWORD_NUM_EDITION) {\n        this.connection._edition = keyTextValue;\n      }\n    }\n    numBytes = buf.readUB2(); // registration\n    if (numBytes > 0) {\n      buf.skip(numBytes);\n    }\n    if (this.arrayDmlRowCounts) {\n      const numRows = buf.readUB4();\n      const rowCounts = this.options.dmlRowCounts = [];\n      for (let i = 0; i < numRows; i++) {\n        const rowCount = buf.readUB8();\n        rowCounts.push(rowCount);\n      }\n    }\n  }\n  async postProcess() {\n    if (this.deferredErr) {\n      throw this.deferredErr;\n    }\n    if (this.outVariables) {\n      for (const variable of this.outVariables) {\n        if (variable.isArray) {\n          if (variable.outConverter) {\n            for (let pos = 0; pos < variable.numElementsInArray; pos++) {\n              variable.values[0][pos] = await variable.outConverter(variable.values[0][pos]);\n            }\n          }\n        } else {\n          if (variable.outConverter) {\n            variable.values[0] = await variable.outConverter(variable.values[0]);\n          }\n        }\n      }\n    }\n    await this.connection._populatePartialDbObjectTypes();\n    for (const resultSet of this.resultSetsToSetup) {\n      resultSet._setup(this.options, resultSet.metadata);\n      // LOBs always require define and they change the type that is actually\n      // returned by the server\n      for (const variable of resultSet.statement.queryVars) {\n        if (variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB || variable.type === types.DB_TYPE_BLOB || variable.type === types.DB_TYPE_JSON) {\n          if (variable.type !== variable.fetchInfo.fetchType) {\n            variable.type = variable.fetchInfo.fetchType;\n            variable.maxSize = constants.TNS_MAX_LONG_LENGTH;\n          }\n          if (!resultSet.statement.noPrefetch) {\n            resultSet.statement.requiresDefine = true;\n            resultSet.statement.noPrefetch = true;\n          }\n        }\n      }\n    }\n  }\n  preProcess() {\n    if (this.statement.isReturning && !this.parseOnly) {\n      this.outVariables = [];\n      for (const bindInfo of this.statement.bindInfoList) {\n        if (bindInfo.isReturnBind) {\n          this.outVariables.push(bindInfo.bindVar);\n        }\n      }\n    }\n    if (this.statement.isQuery) {\n      this.inFetch = true;\n      if (this.statement.queryVars) {\n        this.outVariables = [];\n        for (let i = 0; i < this.statement.queryVars.length; i++) {\n          this.outVariables.push(this.statement.queryVars[i]);\n        }\n      }\n    }\n  }\n  processBitVector(buf) {\n    this.numColumnsSent = buf.readUB2();\n    let numBytes = Math.floor(this.statement.numQueryVars / 8);\n    if (this.statement.numQueryVars % 8 > 0) {\n      numBytes += 1;\n    }\n    this.bitVector = Buffer.from(buf.readBytes(numBytes));\n  }\n  processBindParams(buf, params) {\n    const bindVars = [];\n    const nonReturningParams = [];\n    for (const bindInfo of params) {\n      if (!bindInfo.isReturnBind) {\n        nonReturningParams.push(bindInfo);\n      }\n      bindVars.push(bindInfo.bindVar);\n    }\n    this.writeColumnMetadata(buf, bindVars);\n    return nonReturningParams;\n  }\n  writeColumnMetadata(buf, bindVars) {\n    for (const variable of bindVars) {\n      let oraTypeNum = variable.type._oraTypeNum;\n      let maxSize = variable.maxSize || variable.type._bufferSizeFactor;\n      let lobPrefetchLength = 0;\n\n      // NCHAR, NVARCHAR reports ORA-01460: unimplemented or unreasonable\n      // conversion requested if maxSize is not multiplied by the\n      // bufferSizeFactor\n      if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        maxSize *= variable.type._bufferSizeFactor;\n      }\n      if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {\n        oraTypeNum = constants.TNS_DATA_TYPE_VARCHAR;\n        maxSize = constants.TNS_MAX_UROWID_LENGTH;\n      }\n      let flag = constants.TNS_BIND_USE_INDICATORS;\n      if (variable.isArray) {\n        flag |= constants.TNS_BIND_ARRAY;\n      }\n      let contFlag = 0;\n      if (variable.type === types.DB_TYPE_BLOB || variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB) {\n        contFlag = constants.TNS_LOB_PREFETCH_FLAG;\n      } else if (variable.type === types.DB_TYPE_JSON) {\n        contFlag = constants.TNS_LOB_PREFETCH_FLAG;\n        maxSize = lobPrefetchLength = constants.TNS_JSON_MAX_LENGTH;\n      }\n      buf.writeUInt8(oraTypeNum);\n      buf.writeUInt8(flag);\n      // precision and scale are always written as zero as the server\n      // expects that and complains if any other value is sent!\n      buf.writeUInt8(0);\n      buf.writeUInt8(0);\n      if (maxSize > buf.caps.maxStringSize) {\n        buf.writeUB4(constants.TNS_MAX_LONG_LENGTH);\n      } else {\n        buf.writeUB4(maxSize);\n      }\n      if (variable.isArray) {\n        buf.writeUB4(variable.maxArraySize);\n      } else {\n        buf.writeUB4(0); // max num elements\n      }\n\n      buf.writeUB4(contFlag);\n      if (variable.objType) {\n        const objType = variable.objType;\n        buf.writeUB4(objType.oid.length);\n        buf.writeBytesWithLength(objType.oid);\n        buf.writeUB2(objType.version);\n      } else {\n        buf.writeUB4(0); // OID\n        buf.writeUB2(0); // version\n      }\n\n      if (variable.type._csfrm !== 0) {\n        buf.writeUB2(constants.TNS_CHARSET_UTF8);\n      } else {\n        buf.writeUB2(0);\n      }\n      buf.writeUInt8(variable.type._csfrm);\n      buf.writeUB4(lobPrefetchLength); // max chars (LOB prefetch)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n        buf.writeUB4(0); // oaccolid\n      }\n    }\n  }\n\n  writeBindParamsRow(buf, params, pos) {\n    const offset = this.offset;\n    let foundLong = false;\n    for (const bindInfo of params) {\n      if (bindInfo.isReturnBind) continue;\n      const variable = bindInfo.bindVar;\n      if (variable.isArray) {\n        const numElements = variable.values.length;\n        buf.writeUB4(numElements);\n        for (let i = 0; i < numElements; i++) {\n          this.writeBindParamsColumn(buf, variable, variable.values[i]);\n        }\n      } else {\n        if (variable.maxSize > buf.caps.maxStringSize) {\n          foundLong = true;\n        } else {\n          this.writeBindParamsColumn(buf, variable, variable.values[pos + offset]);\n        }\n      }\n    }\n    if (foundLong) {\n      for (const bindInfo of params) {\n        if (bindInfo.isReturnBind) continue;\n        const variable = bindInfo.bindVar;\n        if (variable.maxSize > buf.caps.maxStringSize) {\n          this.writeBindParamsColumn(buf, variable, variable.values[pos + offset]);\n        }\n      }\n    }\n  }\n  writeBindParamsColumn(buf, variable, value) {\n    const oraTypeNum = variable.type._oraTypeNum;\n    let tempVal;\n    if ((value === undefined || value === null) && oraTypeNum !== constants.TNS_DATA_TYPE_CURSOR && oraTypeNum !== constants.TNS_DATA_TYPE_JSON) {\n      if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n        buf.writeUInt8(constants.TNS_ESCAPE_CHAR);\n        buf.writeUInt8(1);\n      } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n        buf.writeUB4(0); // TOID\n        buf.writeUB4(0); // OID\n        buf.writeUB4(0); // snapshot\n        buf.writeUB4(0); // version\n        buf.writeUB4(0); // packed data length\n        buf.writeUB4(constants.TNS_OBJ_TOP_LEVEL); // flags\n      } else {\n        buf.writeUInt8(0);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER || oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {\n      if (typeof value === 'boolean') {\n        tempVal = value ? \"1\" : \"0\";\n      } else {\n        tempVal = value.toString();\n      }\n      buf.writeOracleNumber(tempVal);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR || oraTypeNum === constants.TNS_DATA_TYPE_CHAR || oraTypeNum === constants.TNS_DATA_TYPE_LONG || oraTypeNum === constants.TNS_DATA_TYPE_RAW || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {\n      if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        buf.caps.checkNCharsetId();\n        value = Buffer.from(value, constants.TNS_ENCODING_UTF16).swap16();\n      } else {\n        value = Buffer.from(value);\n      }\n      buf.writeBytesWithLength(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ) {\n      buf.writeOracleDate(value, variable.type);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {\n      buf.writeBinaryDouble(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {\n      buf.writeBinaryFloat(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {\n      let cursor = value;\n      if (!value) {\n        cursor = this.connection._createResultSet();\n      }\n      if (cursor.statement.cursorId === 0) {\n        buf.writeUInt8(1);\n        buf.writeUInt8(0);\n      } else {\n        buf.writeUB4(1);\n        buf.writeUB4(cursor.statement.cursorId);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n      if (value) {\n        buf.writeUInt8(2);\n        buf.writeUInt16BE(0x0101);\n      } else {\n        buf.writeUInt16BE(0x0100);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB) {\n      buf.writeUB4(value._locator.length);\n      buf.writeBytesWithLength(value._locator);\n    } else if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {\n      buf.writeBytesWithLength(Buffer.from(value));\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {\n      buf.writeOson(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n      buf.writeDbObject(value);\n    } else {\n      const message = `Binding data of type ${variable.type}`;\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, message);\n    }\n  }\n  createCursorFromDescribe(buf) {\n    const resultSet = this.connection._createResultSet(this.options);\n    resultSet.options.moreRowsToFetch = true;\n    resultSet.statement.isQuery = true;\n    resultSet.statement.requiresFullExecute = true;\n    this.processDescribeInfo(buf, resultSet);\n    return resultSet;\n  }\n  processImplicitResultSet(buf) {\n    this.options.implicitResultSet = [];\n    const numResults = buf.readUB4();\n    for (let i = 0; i < numResults; i++) {\n      const numBytes = buf.readUInt8();\n      buf.skipBytes(numBytes);\n      const childResultSet = this.createCursorFromDescribe(buf);\n      childResultSet.statement.cursorId = buf.readUB2();\n      this.options.implicitResultSet.push(childResultSet);\n    }\n  }\n}\nconst isNullLength = len => {\n  return len === 0 || len === constants.TNS_NULL_LENGTH_INDICATOR;\n};\nmodule.exports = MessageWithData;","map":{"version":3,"names":["Buffer","require","utils","constants","Message","ThinDbObjectImpl","ThinLobImpl","errors","types","MessageWithData","constructor","connection","statement","options","offset","numExecs","arrayDmlRowCounts","requiresDefine","rowIndex","bufferRowCount","dmlRowCounts","batchErrors","outVariables","inFetch","parseOnly","resultSetsToSetup","deferredErr","processMessage","buf","messageType","TNS_MSG_TYPE_DESCRIBE_INFO","skipBytesChunked","prevQueryVars","queryVars","numQueryVars","bufferRowIndex","processDescribeInfo","resultSet","TNS_MSG_TYPE_ROW_HEADER","processRowHeader","TNS_MSG_TYPE_ROW_DATA","processRowData","TNS_MSG_TYPE_IMPLICIT_RESULTSET","processImplicitResultSet","TNS_MSG_TYPE_BIT_VECTOR","processBitVector","TNS_MSG_TYPE_IO_VECTOR","processIOVector","TNS_MSG_TYPE_FLUSH_OUT_BINDS","flushOutBinds","TNS_MSG_TYPE_ERROR","processErrorInfo","hasMoreData","processedError","errorInfo","cursorId","isPlSql","rowCount","lastRowid","encodeRowID","rowID","num","TNS_ERR_NO_DATA_FOUND","isQuery","errorOccurred","moreRowsToFetch","statementCache","delete","sql","returnToCache","_adjustFetchType","pVar","cVar","fetchInfo","dbType","_oraTypeNum","TNS_DATA_TYPE_CLOB","fetchType","TNS_DATA_TYPE_LONG","TNS_DATA_TYPE_BLOB","TNS_DATA_TYPE_LONG_RAW","type","maxSize","skipUB4","readUB4","skipUB1","metadata","i","variable","processColumnInfo","length","push","numBytes","columnNum","dataType","readUInt8","precision","readInt8","scale","TNS_DATA_TYPE_NUMBER","TNS_DATA_TYPE_INTERVAL_DS","TNS_DATA_TYPE_TIMESTAMP","TNS_DATA_TYPE_TIMESTAMP_LTZ","TNS_DATA_TYPE_TIMESTAMP_TZ","readSB2","oid","from","readBytesWithLength","skipUB2","csfrm","size","TNS_DATA_TYPE_RAW","caps","ttcFieldVersion","TNS_CCAP_FIELD_VERSION_12_2","nullable","Boolean","name","readStr","CSFRM_IMPLICIT","schema","typeName","getTypeByOraTypeNum","DB_TYPE_VARCHAR","DB_TYPE_NVARCHAR","DB_TYPE_CHAR","DB_TYPE_NCHAR","DB_TYPE_RAW","byteSize","DB_TYPE_NUMBER","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_TZ","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_OBJECT","dbTypeClass","_getDbObjectType","undefined","partial","_partialDbObjectTypes","values","Array","fetchArraySize","bitVector","isDuplicateData","columnName","byteNum","Math","floor","bitNum","value","col","entries","isArray","numElementsInArray","fill","pos","processColumnData","isReturning","numRows","j","outConverter","lastRawValue","lastRowIndex","temp16","readUB2","temp32","numBinds","skipBytes","bindInfo","bindInfoList","bindDir","TNS_BIND_DIR_INPUT","bindVar","oraTypeNum","_csfrm","colValue","TNS_DATA_TYPE_UROWID","TNS_DATA_TYPE_VARCHAR","TNS_DATA_TYPE_CHAR","CSFRM_NCHAR","checkNCharsetId","readOracleNumber","parseFloat","TNS_DATA_TYPE_DATE","useLocalTime","readOracleDate","TNS_DATA_TYPE_ROWID","isNullLength","rowid","readRowID","readURowID","TNS_DATA_TYPE_BINARY_DOUBLE","readBinaryDouble","TNS_DATA_TYPE_BINARY_FLOAT","readBinaryFloat","TNS_DATA_TYPE_BINARY_INTEGER","TNS_DATA_TYPE_CURSOR","createCursorFromDescribe","dir","BIND_IN","nullifyInvalidCursor","throwErr","ERR_INVALID_REF_CURSOR","TNS_DATA_TYPE_BOOLEAN","readBool","bvalue","readUB8","chunkSize","locator","init","TNS_DATA_TYPE_JSON","readOson","TNS_DATA_TYPE_INT_NAMED","obj","readDbObject","packedData","objType","typeClass","toid","ERR_UNSUPPORTED_DATA_TYPE","actualNumBytes","readSB4","saveDeferredErr","ERR_INSUFFICIENT_BUFFER_FOR_BINDS","maxStringSize","skipSB4","processReturnParameter","keywordNum","keyTextValue","numParams","TNS_KEYWORD_NUM_CURRENT_SCHEMA","currentSchema","TNS_KEYWORD_NUM_EDITION","_edition","skip","rowCounts","postProcess","_populatePartialDbObjectTypes","_setup","DB_TYPE_CLOB","DB_TYPE_NCLOB","DB_TYPE_BLOB","DB_TYPE_JSON","TNS_MAX_LONG_LENGTH","noPrefetch","preProcess","isReturnBind","numColumnsSent","readBytes","processBindParams","params","bindVars","nonReturningParams","writeColumnMetadata","_bufferSizeFactor","lobPrefetchLength","includes","TNS_MAX_UROWID_LENGTH","flag","TNS_BIND_USE_INDICATORS","TNS_BIND_ARRAY","contFlag","TNS_LOB_PREFETCH_FLAG","TNS_JSON_MAX_LENGTH","writeUInt8","writeUB4","maxArraySize","writeBytesWithLength","writeUB2","version","TNS_CHARSET_UTF8","writeBindParamsRow","foundLong","numElements","writeBindParamsColumn","tempVal","TNS_ESCAPE_CHAR","TNS_OBJ_TOP_LEVEL","toString","writeOracleNumber","TNS_ENCODING_UTF16","swap16","writeOracleDate","writeBinaryDouble","writeBinaryFloat","cursor","_createResultSet","writeUInt16BE","_locator","writeOson","writeDbObject","message","ERR_NOT_IMPLEMENTED","requiresFullExecute","implicitResultSet","numResults","childResultSet","len","TNS_NULL_LENGTH_INDICATOR","module","exports"],"sources":["C:/Users/aphen/OneDrive/Documents/GitHub/react-voice-actors/node_modules/oracledb/lib/thin/protocol/messages/withData.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst utils = require(\"../utils\");\nconst constants = require(\"../constants.js\");\nconst Message = require(\"./base.js\");\nconst ThinDbObjectImpl = require(\"../../dbObject.js\");\nconst ThinLobImpl = require(\"../../lob.js\");\nconst errors = require('../../../errors');\nconst types = require('../../../types.js');\n\n/**\n * Handles data like row header, rowdata , ... recevied from an RPC Execute\n *\n * @class MessageWithData\n * @extends {Message}\n */\nclass MessageWithData extends Message {\n  constructor(connection, statement = null, options = null) {\n    super(connection);\n    this.statement = statement;\n    this.options = options;\n    this.offset = 0;\n    this.numExecs = 1;\n    this.arrayDmlRowCounts = false;\n    this.requiresDefine = false;\n    this.rowIndex = statement.bufferRowCount || 0;\n    this.dmlRowCounts = [];\n    this.batchErrors = false;\n    this.outVariables = [];\n    this.inFetch = false;\n    this.parseOnly = false;\n    this.resultSetsToSetup = [];\n    this.deferredErr = null;\n  }\n\n  /**\n    * processMessage() - Process the data type message\n    */\n  processMessage(buf, messageType) {\n    if (messageType === constants.TNS_MSG_TYPE_DESCRIBE_INFO) {\n      buf.skipBytesChunked();\n      const prevQueryVars = this.statement.queryVars;\n      this.statement.queryVars = [];\n      this.statement.numQueryVars = 0;\n      this.statement.bufferRowCount = 0;\n      this.statement.bufferRowIndex = 0;\n      this.processDescribeInfo(buf, this.resultSet, prevQueryVars);\n      this.outVariables = this.statement.queryVars;\n    } else if (messageType === constants.TNS_MSG_TYPE_ROW_HEADER) {\n      this.processRowHeader(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_ROW_DATA) {\n      this.processRowData(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_IMPLICIT_RESULTSET) {\n      this.processImplicitResultSet(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_BIT_VECTOR) {\n      this.processBitVector(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_IO_VECTOR) {\n      this.processIOVector(buf);\n    } else if (messageType === constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS) {\n      this.flushOutBinds = true;\n    } else if (messageType === constants.TNS_MSG_TYPE_ERROR) {\n      this.processErrorInfo(buf);\n    } else {\n      super.processMessage(buf, messageType);\n    }\n  }\n\n  hasMoreData() {\n    return !this.processedError && !this.flushOutBinds;\n  }\n\n  processErrorInfo(buf) {\n    super.processErrorInfo(buf);\n    if (this.errorInfo.cursorId !== 0) {\n      this.statement.cursorId = this.errorInfo.cursorId;\n    }\n    if (!this.statement.isPlSql) {\n      this.statement.rowCount = this.errorInfo.rowCount;\n    }\n    // we do not set the lastRowid if the rows affected is 0\n    if (this.errorInfo.rowCount > 0) {\n      this.statement.lastRowid = utils.encodeRowID(this.errorInfo.rowID);\n    }\n    this.options.batchErrors = this.errorInfo.batchErrors;\n    if (this.batchErrors && this.options.batchErrors === null) {\n      this.options.batchErrors = [];\n    }\n    if (this.errorInfo.num === constants.TNS_ERR_NO_DATA_FOUND && this.statement.isQuery) {\n      this.errorInfo.num = 0;\n      this.errorOccurred = false;\n      this.statement.moreRowsToFetch = false;\n    } else if (this.errorInfo.num !== 0 && this.errorInfo.cursorId !== 0) {\n      this.connection.statementCache.delete(this.statement.sql);\n      this.statement.returnToCache = false;\n    }\n    if (this.errorInfo.batchErrors) {\n      this.errorOccurred = false;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // If we have fetched this column earlier, we set that\n  // fetch type for the describe info variable received\n  // assuming the returned column order is same as previous.\n  //---------------------------------------------------------------------------\n  _adjustFetchType(pVar, cVar) {\n    if ((cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_CLOB\n       && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG)\n        || (cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_BLOB\n          && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW)) {\n      cVar.type = pVar.fetchInfo.fetchType;\n      cVar.maxSize = pVar.maxSize;\n    }\n  }\n\n  processDescribeInfo(buf, resultSet, prevQueryVars) {\n    const statement = resultSet.statement;\n    buf.skipUB4();                              // max row size\n    statement.numQueryVars = buf.readUB4();\n    if (statement.numQueryVars > 0) {\n      buf.skipUB1();\n    }\n    resultSet.metadata = [];\n    for (let i = 0; i < statement.numQueryVars; i++) {\n      const variable = this.processColumnInfo(buf, i + 1);\n      if (prevQueryVars && i < prevQueryVars.length) {\n        this._adjustFetchType(prevQueryVars[i], variable);\n      }\n      statement.queryVars.push(variable);\n      resultSet.metadata.push(variable.fetchInfo);\n    }\n\n    let numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked();                   // current date\n    }\n    buf.skipUB4();                              // dcbflag\n    buf.skipUB4();                              // dcbmdbz\n    buf.skipUB4();                              // dcbmnpr\n    buf.skipUB4();                              // dcbmxpr\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked();\n    }\n\n    this.resultSetsToSetup.push(resultSet);\n  }\n\n  processColumnInfo(buf, columnNum) {\n    const dataType = buf.readUInt8();\n    buf.skipUB1(); // flags\n    const precision = buf.readInt8();\n    let scale;\n    if (dataType === constants.TNS_DATA_TYPE_NUMBER ||\n        dataType === constants.TNS_DATA_TYPE_INTERVAL_DS ||\n        dataType === constants.TNS_DATA_TYPE_TIMESTAMP ||\n        dataType === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ ||\n        dataType === constants.TNS_DATA_TYPE_TIMESTAMP_TZ) {\n      scale = buf.readSB2();\n    } else {\n      scale = buf.readInt8();\n    }\n    const maxSize = buf.readUB4();\n    buf.skipUB4();                              // max number of array elements\n    buf.skipUB4();                              // cont flags\n    let oid;\n    let numBytes = buf.readUB4();               // OID\n    if (numBytes > 0) {\n      oid = Buffer.from(buf.readBytesWithLength());\n    }\n    buf.skipUB2();                              // version\n    buf.skipUB2();                              // character set id\n    const csfrm = buf.readUInt8();              // character set form\n    let size = buf.readUB4();\n    if (dataType === constants.TNS_DATA_TYPE_RAW) {\n      size = maxSize;\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.skipUB4();                            // oaccolid\n    }\n    const nullable = Boolean(buf.readUInt8());\n    buf.skipUB1();                              // v7 length of name\n    let name;\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      name = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    let schema;\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      schema = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    numBytes = buf.readUB4();\n    let typeName;\n    if (numBytes > 0) {\n      typeName = buf.readStr(constants.CSFRM_IMPLICIT);\n    }\n    buf.skipUB2();                              // column position\n    buf.skipUB4();                              // uds flag\n\n    // build metadata\n    const fetchInfo = {\n      name: name,\n      dbType: types.getTypeByOraTypeNum(dataType, csfrm),\n      nullable: nullable\n    };\n    switch (fetchInfo.dbType) {\n      case types.DB_TYPE_VARCHAR:\n      case types.DB_TYPE_NVARCHAR:\n      case types.DB_TYPE_CHAR:\n      case types.DB_TYPE_NCHAR:\n      case types.DB_TYPE_RAW:\n        fetchInfo.byteSize = size;\n        break;\n      case types.DB_TYPE_NUMBER:\n        fetchInfo.precision = precision;\n        break;\n      case types.DB_TYPE_TIMESTAMP:\n      case types.DB_TYPE_TIMESTAMP_TZ:\n      case types.DB_TYPE_TIMESTAMP_LTZ:\n        fetchInfo.precision = scale;\n        break;\n      case types.DB_TYPE_OBJECT:\n        fetchInfo.dbTypeClass = this.connection._getDbObjectType(schema,\n          typeName, undefined, oid);\n        if (fetchInfo.dbTypeClass.partial) {\n          this.connection._partialDbObjectTypes.push(fetchInfo.dbTypeClass);\n        }\n        break;\n      default:\n        break;\n    }\n    if (fetchInfo.dbType === types.DB_TYPE_NUMBER) {\n      fetchInfo.scale = scale;\n    }\n    return {\n      fetchInfo: fetchInfo,\n      type: fetchInfo.dbType,\n      maxSize: maxSize,\n      columnNum: columnNum,\n      values: new Array(this.options.fetchArraySize)\n    };\n  }\n\n  processRowHeader(buf) {\n    buf.skipUB1();                              // flags\n    buf.skipUB2();                              // num requests\n    buf.skipUB4();                              // iteration number\n    buf.skipUB4();                              // num iters\n    buf.skipUB2();                              // buffer length\n    let numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      this.bitVector = Buffer.from(buf.readBytesWithLength());\n    }\n    numBytes = buf.readUB4();\n    if (numBytes > 0) {\n      buf.skipBytesChunked();                   // rxhrid\n    }\n  }\n\n  isDuplicateData(columnName) {\n    if (!this.bitVector) {\n      return false;\n    }\n    const byteNum = Math.floor(columnName / 8);\n    const bitNum = columnName % 8;\n    return (this.bitVector[byteNum] & (1 << bitNum)) === 0;\n  }\n\n  processRowData(buf) {\n    let value;\n    for (const [col, variable] of this.outVariables.entries()) {\n      if (variable.isArray) {\n        variable.numElementsInArray = buf.readUB4();\n        const values = new Array(variable.numElementsInArray).fill(null);\n        for (let pos = 0; pos < variable.numElementsInArray; pos++) {\n          value = this.processColumnData(buf, variable, pos);\n          values[pos] = value;\n        }\n        variable.values[this.rowIndex] = values;\n      } else if (this.statement.isReturning) {\n        const numRows = buf.readUB4();\n        const values = Array(numRows).fill(null);\n        for (let j = 0; j < numRows; j++) {\n          values[j] = this.processColumnData(buf, variable, j);\n        }\n        variable.values[this.rowIndex] = values;\n      } else if (this.isDuplicateData(col)) {\n        if (this.rowIndex === 0 && variable.outConverter) {\n          value = variable.lastRawValue;\n        } else {\n          value = variable.values[this.statement.lastRowIndex];\n        }\n        variable.values[this.rowIndex] = value;\n      } else {\n        value = this.processColumnData(buf, variable, this.rowIndex);\n        variable.values[this.rowIndex] = value;\n      }\n    }\n    this.rowIndex++;\n    if (this.inFetch) {\n      this.statement.lastRowIndex = this.rowIndex - 1;\n      this.statement.bufferRowCount++;\n      this.bitVector = null;\n    }\n  }\n\n  processIOVector(buf) {\n    let numBytes;\n    buf.skipUB1();                              // flag\n    const temp16 = buf.readUB2();              // num requests\n    const temp32 = buf.readUB4();              // iter num\n    const numBinds = temp32 * 256 + temp16;\n    buf.skipUB4();                              // num iters this time\n    buf.skipUB2();                              // uac buffer length\n    numBytes = buf.readUB2();                   // bit vector for fast fetch\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    numBytes = buf.readUB2();                   // rowid\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    this.outVariables = [];\n    for (let i = 0; i < numBinds; i++) {              // bind directions\n      const bindInfo = this.statement.bindInfoList[i];\n      bindInfo.bindDir = buf.readUInt8();\n      if (bindInfo.bindDir === constants.TNS_BIND_DIR_INPUT) {\n        continue;\n      }\n      this.outVariables.push(bindInfo.bindVar);\n    }\n  }\n\n  processColumnData(buf, variable) {\n    const dbType = variable.type;\n    const oraTypeNum = dbType._oraTypeNum;\n    const csfrm = dbType._csfrm;\n    const maxSize = variable.maxSize;\n\n    let colValue = null;\n    if (maxSize === 0 && oraTypeNum !== constants.TNS_DATA_TYPE_LONG\n      && oraTypeNum !== constants.TNS_DATA_TYPE_LONG_RAW\n      && oraTypeNum !== constants.TNS_DATA_TYPE_UROWID) {\n      colValue = null;\n    } else if (\n      oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR ||\n      oraTypeNum === constants.TNS_DATA_TYPE_CHAR ||\n      oraTypeNum === constants.TNS_DATA_TYPE_LONG\n    ) {\n      if (csfrm === constants.CSFRM_NCHAR) {\n        buf.caps.checkNCharsetId();\n      }\n      colValue = buf.readStr(csfrm);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_RAW ||\n      oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {\n      colValue = buf.readBytesWithLength();\n      if (colValue !== null) {\n        colValue = Buffer.from(colValue);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER) {\n      colValue = buf.readOracleNumber();\n      if (!this.inFetch && colValue !== null)\n        colValue = parseFloat(colValue);\n    } else if (\n      oraTypeNum === constants.TNS_DATA_TYPE_DATE ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ\n    ) {\n      const useLocalTime = (oraTypeNum === constants.TNS_DATA_TYPE_DATE ||\n        oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP);\n      colValue = buf.readOracleDate(useLocalTime);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_ROWID) {\n      if (!this.inFetch) {\n        colValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      } else {\n        const numBytes = buf.readUInt8();\n        if (isNullLength(numBytes)) {\n          colValue = null;\n        } else {\n          const rowid = buf.readRowID();\n          colValue = utils.encodeRowID(rowid);\n        }\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_UROWID) {\n      if (!this.inFetch) {\n        colValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      } else {\n        colValue = buf.readURowID();\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {\n      colValue = buf.readBinaryDouble();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {\n      colValue = buf.readBinaryFloat();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {\n      colValue = buf.readOracleNumber();\n      if (colValue !== null)\n        colValue = parseFloat(colValue);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {\n      const numBytes = buf.readUInt8();\n      if (isNullLength(numBytes)) {\n        colValue = null;\n      } else {\n        colValue = this.createCursorFromDescribe(buf);\n        colValue.statement.cursorId = buf.readUB2();\n        // If the cursor ID is 0 for the returned ref cursor then\n        // it is an invalid cursor\n        if (colValue.statement.cursorId === 0 && variable.dir !== constants.BIND_IN) {\n          if (this.options.nullifyInvalidCursor) {\n            colValue = null;\n          } else {\n            errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n          }\n        }\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n      colValue = buf.readBool();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB) {\n      const bvalue = buf.readUB4();\n      if (bvalue > 0) { // Non Null data in column\n        colValue = new ThinLobImpl();\n        const length = buf.readUB8();\n        const chunkSize = buf.readUB4();\n        const locator = Buffer.from(buf.readBytesWithLength());\n        colValue.init(this.connection, locator, dbType, length, chunkSize);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {\n      colValue = buf.readOson();\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n      const obj = buf.readDbObject();\n      if (obj.packedData) {\n        const objType = (variable.fetchInfo) ? variable.fetchInfo.dbTypeClass :\n          variable.typeClass;\n        colValue = new ThinDbObjectImpl(objType, obj.packedData);\n        colValue.toid = obj.toid;\n        colValue.oid = obj.oid;\n      }\n    } else {\n      errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE, dbType.num,\n        variable.columnNum);\n    }\n\n    if (!this.inFetch) {\n      const actualNumBytes = buf.readSB4();\n      if (actualNumBytes < 0 && oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n        colValue = null;\n      } else if (actualNumBytes !== 0 && colValue !== null) {\n        this.saveDeferredErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_LONG || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW || variable.maxSize > buf.caps.maxStringSize) {\n      buf.skipSB4();                            // null indicator\n      buf.skipUB4();                            // return code\n    }\n    return colValue;\n  }\n\n  processReturnParameter(buf) {\n    let keywordNum = 0;\n    let keyTextValue;\n    let numParams = buf.readUB2();              // al8o4l (ignored)\n\n    for (let i = 0; i < numParams; i++) {\n      buf.skipUB4();\n    }\n    let numBytes = buf.readUB2();               // al8txl (ignored)\n    if (numBytes > 0) {\n      buf.skipBytes(numBytes);\n    }\n    numParams = buf.readUB2();                  // num key/value pairs\n    for (let i = 0; i < numParams; i++) {\n      numBytes = buf.readUB2();                 // key\n      if (numBytes > 0) {\n        keyTextValue = buf.readStr(constants.CSFRM_IMPLICIT);\n      }\n      numBytes = buf.readUB2();                 // value\n      if (numBytes > 0) {\n        buf.skipBytesChunked();\n      }\n      keywordNum = buf.readUB2();               // keyword num\n      if (keywordNum === constants.TNS_KEYWORD_NUM_CURRENT_SCHEMA) {\n        this.connection.currentSchema = keyTextValue;\n      } else if (keywordNum === constants.TNS_KEYWORD_NUM_EDITION) {\n        this.connection._edition = keyTextValue;\n      }\n    }\n    numBytes = buf.readUB2();                   // registration\n    if (numBytes > 0) {\n      buf.skip(numBytes);\n    }\n    if (this.arrayDmlRowCounts) {\n      const numRows = buf.readUB4();\n      const rowCounts = this.options.dmlRowCounts = [];\n      for (let i = 0; i < numRows; i++) {\n        const rowCount = buf.readUB8();\n        rowCounts.push(rowCount);\n      }\n    }\n  }\n\n  async postProcess() {\n    if (this.deferredErr) {\n      throw this.deferredErr;\n    }\n\n    if (this.outVariables) {\n      for (const variable of this.outVariables) {\n        if (variable.isArray) {\n          if (variable.outConverter) {\n            for (let pos = 0; pos < variable.numElementsInArray; pos++) {\n              variable.values[0][pos] = await variable.outConverter(variable.values[0][pos]);\n            }\n          }\n        } else {\n          if (variable.outConverter) {\n            variable.values[0] = await variable.outConverter(variable.values[0]);\n          }\n        }\n      }\n    }\n    await this.connection._populatePartialDbObjectTypes();\n    for (const resultSet of this.resultSetsToSetup) {\n      resultSet._setup(this.options, resultSet.metadata);\n      // LOBs always require define and they change the type that is actually\n      // returned by the server\n      for (const variable of resultSet.statement.queryVars) {\n        if (variable.type === types.DB_TYPE_CLOB ||\n            variable.type === types.DB_TYPE_NCLOB ||\n            variable.type === types.DB_TYPE_BLOB ||\n            variable.type === types.DB_TYPE_JSON) {\n          if (variable.type !== variable.fetchInfo.fetchType) {\n            variable.type = variable.fetchInfo.fetchType;\n            variable.maxSize = constants.TNS_MAX_LONG_LENGTH;\n          }\n          if (!resultSet.statement.noPrefetch) {\n            resultSet.statement.requiresDefine = true;\n            resultSet.statement.noPrefetch = true;\n          }\n        }\n      }\n    }\n  }\n\n  preProcess() {\n    if (this.statement.isReturning && !this.parseOnly) {\n      this.outVariables = [];\n      for (const bindInfo of this.statement.bindInfoList) {\n        if (bindInfo.isReturnBind) {\n          this.outVariables.push(bindInfo.bindVar);\n        }\n      }\n    }\n\n    if (this.statement.isQuery) {\n      this.inFetch = true;\n      if (this.statement.queryVars) {\n        this.outVariables = [];\n        for (let i = 0; i < this.statement.queryVars.length; i++) {\n          this.outVariables.push(this.statement.queryVars[i]);\n        }\n      }\n    }\n  }\n\n  processBitVector(buf) {\n    this.numColumnsSent = buf.readUB2();\n    let numBytes = Math.floor(this.statement.numQueryVars / 8);\n    if (this.statement.numQueryVars % 8 > 0) {\n      numBytes += 1;\n    }\n    this.bitVector = Buffer.from(buf.readBytes(numBytes));\n  }\n\n  processBindParams(buf, params) {\n    const bindVars = [];\n    const nonReturningParams = [];\n    for (const bindInfo of params) {\n      if (!bindInfo.isReturnBind) {\n        nonReturningParams.push(bindInfo);\n      }\n      bindVars.push(bindInfo.bindVar);\n    }\n    this.writeColumnMetadata(buf, bindVars);\n    return nonReturningParams;\n  }\n\n  writeColumnMetadata(buf, bindVars) {\n    for (const variable of bindVars) {\n      let oraTypeNum = variable.type._oraTypeNum;\n      let maxSize = variable.maxSize || variable.type._bufferSizeFactor;\n      let lobPrefetchLength = 0;\n\n      // NCHAR, NVARCHAR reports ORA-01460: unimplemented or unreasonable\n      // conversion requested if maxSize is not multiplied by the\n      // bufferSizeFactor\n      if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        maxSize *= variable.type._bufferSizeFactor;\n      }\n      if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {\n        oraTypeNum = constants.TNS_DATA_TYPE_VARCHAR;\n        maxSize = constants.TNS_MAX_UROWID_LENGTH;\n      }\n      let flag = constants.TNS_BIND_USE_INDICATORS;\n      if (variable.isArray) {\n        flag |= constants.TNS_BIND_ARRAY;\n      }\n      let contFlag = 0;\n      if (variable.type === types.DB_TYPE_BLOB ||\n          variable.type === types.DB_TYPE_CLOB ||\n          variable.type === types.DB_TYPE_NCLOB) {\n        contFlag = constants.TNS_LOB_PREFETCH_FLAG;\n      } else if (variable.type === types.DB_TYPE_JSON) {\n        contFlag = constants.TNS_LOB_PREFETCH_FLAG;\n        maxSize = lobPrefetchLength = constants.TNS_JSON_MAX_LENGTH;\n      }\n      buf.writeUInt8(oraTypeNum);\n      buf.writeUInt8(flag);\n      // precision and scale are always written as zero as the server\n      // expects that and complains if any other value is sent!\n      buf.writeUInt8(0);\n      buf.writeUInt8(0);\n      if (maxSize > buf.caps.maxStringSize) {\n        buf.writeUB4(constants.TNS_MAX_LONG_LENGTH);\n      } else {\n        buf.writeUB4(maxSize);\n      }\n\n      if (variable.isArray) {\n        buf.writeUB4(variable.maxArraySize);\n      } else {\n        buf.writeUB4(0);                        // max num elements\n      }\n      buf.writeUB4(contFlag);\n      if (variable.objType) {\n        const objType = variable.objType;\n        buf.writeUB4(objType.oid.length);\n        buf.writeBytesWithLength(objType.oid);\n        buf.writeUB2(objType.version);\n      } else {\n        buf.writeUB4(0);                        // OID\n        buf.writeUB2(0);                        // version\n      }\n      if (variable.type._csfrm !== 0) {\n        buf.writeUB2(constants.TNS_CHARSET_UTF8);\n      } else {\n        buf.writeUB2(0);\n      }\n      buf.writeUInt8(variable.type._csfrm);\n      buf.writeUB4(lobPrefetchLength);          // max chars (LOB prefetch)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n        buf.writeUB4(0);                        // oaccolid\n      }\n    }\n  }\n\n  writeBindParamsRow(buf, params, pos) {\n    const offset = this.offset;\n    let foundLong = false;\n    for (const bindInfo of params) {\n      if (bindInfo.isReturnBind)\n        continue;\n      const variable = bindInfo.bindVar;\n      if (variable.isArray) {\n        const numElements = variable.values.length;\n        buf.writeUB4(numElements);\n        for (let i = 0; i < numElements; i++) {\n          this.writeBindParamsColumn(buf, variable, variable.values[i]);\n        }\n      } else {\n        if (variable.maxSize > buf.caps.maxStringSize) {\n          foundLong = true;\n        } else {\n          this.writeBindParamsColumn(buf, variable,\n            variable.values[pos + offset]);\n        }\n      }\n    }\n    if (foundLong) {\n      for (const bindInfo of params) {\n        if (bindInfo.isReturnBind)\n          continue;\n        const variable = bindInfo.bindVar;\n        if (variable.maxSize > buf.caps.maxStringSize) {\n          this.writeBindParamsColumn(buf, variable, variable.values[pos + offset]);\n        }\n      }\n    }\n  }\n\n  writeBindParamsColumn(buf, variable, value) {\n    const oraTypeNum = variable.type._oraTypeNum;\n    let tempVal;\n    if ((value === undefined || value === null) && oraTypeNum !== constants.TNS_DATA_TYPE_CURSOR && oraTypeNum !== constants.TNS_DATA_TYPE_JSON) {\n      if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n        buf.writeUInt8(constants.TNS_ESCAPE_CHAR);\n        buf.writeUInt8(1);\n      } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n        buf.writeUB4(0);                // TOID\n        buf.writeUB4(0);                // OID\n        buf.writeUB4(0);                // snapshot\n        buf.writeUB4(0);                // version\n        buf.writeUB4(0);                // packed data length\n        buf.writeUB4(constants.TNS_OBJ_TOP_LEVEL);    // flags\n      } else {\n        buf.writeUInt8(0);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER ||\n      oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {\n      if (typeof value === 'boolean') {\n        tempVal = (value) ? \"1\" : \"0\";\n      } else {\n        tempVal = value.toString();\n      }\n      buf.writeOracleNumber(tempVal);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR ||\n      oraTypeNum === constants.TNS_DATA_TYPE_CHAR ||\n      oraTypeNum === constants.TNS_DATA_TYPE_LONG ||\n      oraTypeNum === constants.TNS_DATA_TYPE_RAW ||\n      oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {\n      if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        buf.caps.checkNCharsetId();\n        value = Buffer.from(value, constants.TNS_ENCODING_UTF16).swap16();\n      } else {\n        value = Buffer.from(value);\n      }\n      buf.writeBytesWithLength(value);\n    } else if (\n      oraTypeNum === constants.TNS_DATA_TYPE_DATE ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ ||\n      oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ\n    ) {\n      buf.writeOracleDate(value, variable.type);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {\n      buf.writeBinaryDouble(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {\n      buf.writeBinaryFloat(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {\n      let cursor = value;\n      if (!value) {\n        cursor = this.connection._createResultSet();\n      }\n      if (cursor.statement.cursorId === 0) {\n        buf.writeUInt8(1);\n        buf.writeUInt8(0);\n      } else {\n        buf.writeUB4(1);\n        buf.writeUB4(cursor.statement.cursorId);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {\n      if (value) {\n        buf.writeUInt8(2);\n        buf.writeUInt16BE(0x0101);\n      } else {\n        buf.writeUInt16BE(0x0100);\n      }\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB) {\n      buf.writeUB4(value._locator.length);\n      buf.writeBytesWithLength(value._locator);\n    } else if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {\n      buf.writeBytesWithLength(Buffer.from(value));\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {\n      buf.writeOson(value);\n    } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {\n      buf.writeDbObject(value);\n    } else {\n      const message = `Binding data of type ${variable.type}`;\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, message);\n    }\n  }\n\n  createCursorFromDescribe(buf) {\n    const resultSet = this.connection._createResultSet(this.options);\n    resultSet.options.moreRowsToFetch = true;\n    resultSet.statement.isQuery = true;\n    resultSet.statement.requiresFullExecute = true;\n    this.processDescribeInfo(buf, resultSet);\n    return resultSet;\n  }\n\n  processImplicitResultSet(buf) {\n    this.options.implicitResultSet = [];\n    const numResults = buf.readUB4();\n    for (let i = 0; i < numResults; i++) {\n      const numBytes = buf.readUInt8();\n      buf.skipBytes(numBytes);\n      const childResultSet = this.createCursorFromDescribe(buf);\n      childResultSet.statement.cursorId = buf.readUB2();\n      this.options.implicitResultSet.push(childResultSet);\n    }\n  }\n}\n\nconst isNullLength = (len) => {\n  return len === 0 || len === constants.TNS_NULL_LENGTH_INDICATOR;\n};\n\nmodule.exports = MessageWithData;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}